
datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

generator client {
  provider      = "prisma-client-js"
  binaryTargets = ["native", "debian-openssl-3.0.x"]
}

model Table {
  id                 String        @id @default(cuid())
  name               String?
  number             Int           @unique
  status             TableStatus   @default(AVAILABLE)
  capacity           Int
  currentOrder       Order?        @relation("TableOrder", fields: [currentOrderId], references: [id], onDelete: SetNull)
  currentOrderId     String?       @unique
  currentOrderTotal  Float?
  createdAt          DateTime      @default(now())
  updatedAt          DateTime      @updatedAt
}

model Order {
  id             String        @id @default(cuid())
  table          Table?        @relation("TableOrder") // Removed tableId and tableNumber from here to rely on the relation
  items          OrderItem[]
  status         OrderStatus   @default(OPEN)
  subtotal       Float
  taxRate        Float
  taxAmount      Float
  totalAmount    Float
  createdAt      DateTime      @default(now())
  updatedAt      DateTime      @updatedAt
  payment        Payment[]
  kot            KOT[]
  externalOrders ExternalOrder[] @relation("OrderExternalOrders")
}

model OrderItem {
  id                String             @id @default(cuid())
  order             Order              @relation(fields: [orderId], references: [id])
  orderId           String
  menuItem          MenuItem           @relation(fields: [menuItemId], references: [id])
  menuItemId        String
  menuItemName      String // Denormalized for convenience
  quantity          Int
  unitPrice         Float
  totalPrice        Float // Calculated: quantity * (unitPrice + sum of modifier priceChanges)
  specialRequests   String?
  selectedModifiers OrderItemSelectedModifier[]

  @@index([orderId])
  @@index([menuItemId])
}

// Join table for OrderItem and Modifier (Many-to-Many for selected modifiers on an order item)
model OrderItemSelectedModifier {
  id          String   @id @default(cuid())
  orderItem   OrderItem @relation(fields: [orderItemId], references: [id], onDelete: Cascade)
  orderItemId String
  modifier    Modifier @relation(fields: [modifierId], references: [id])
  modifierId  String
  // Store details of the modifier at the time of order, in case modifier definitions change later
  modifierName        String
  modifierPriceChange Float

  @@unique([orderItemId, modifierId]) // Ensures a modifier is not selected twice for the same order item
  @@index([orderItemId])
  @@index([modifierId])
}

model MenuItem {
  id                 String             @id @default(cuid())
  name               String             @unique
  description        String?
  price              Float
  imageUrl           String?
  dataAiHint         String?
  category           MenuCategory       @relation(fields: [categoryId], references: [id])
  categoryId         String
  orderItems         OrderItem[]
  availableModifiers MenuItemModifier[] // Link to available modifiers for this menu item

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([categoryId])
}

model MenuCategory {
  id        String     @id @default(cuid())
  name      String     @unique
  iconName  String?
  menuItems MenuItem[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// Join table for MenuItem and Modifier (Many-to-Many for available modifiers for a menu item)
model MenuItemModifier {
  menuItem   MenuItem @relation(fields: [menuItemId], references: [id], onDelete: Cascade)
  menuItemId String
  modifier   Modifier @relation(fields: [modifierId], references: [id], onDelete: Cascade)
  modifierId String

  @@id([menuItemId, modifierId])
  @@index([menuItemId])
  @@index([modifierId])
}

model Modifier {
  id                      String                      @id @default(cuid())
  name                    String                      @unique
  priceChange             Float // Can be positive, negative, or zero
  menuItems               MenuItemModifier[]          // Menu items this modifier is available for
  selectedInOrderItems    OrderItemSelectedModifier[] // Order items where this modifier was selected

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model KOT {
  id        String   @id @default(cuid())
  order     Order    @relation(fields: [orderId], references: [id])
  orderId   String   @unique // A KOT should belong to one order
  // tableNumber is on the Order
  // items (name, quantity, modifiers, specialRequests) are derived from OrderItems at generation time.
  // For simplicity in DB, we might not store KOT items directly if they are always generated on-the-fly.
  // If historical KOTs need to be preserved exactly as printed, then store them.
  // For now, assuming KOT is generated and not stored as a complex object.
  // kotItems  Json? // If we need to store the exact items. Example: [{ name: "Burger", qty: 1, mods: ["Extra Cheese"]}]
  createdAt DateTime @default(now())

  @@index([orderId])
}

model Payment {
  id            String        @id @default(cuid())
  order         Order         @relation(fields: [orderId], references: [id])
  orderId       String
  amount        Float
  method        PaymentMethod
  status        String // e.g., "SUCCESSFUL", "PENDING", "FAILED"
  transactionId String?       @unique
  createdAt     DateTime      @default(now())
  updatedAt     DateTime      @updatedAt

  @@index([orderId])
}

model User {
  id             String          @id @default(cuid())
  email          String          @unique
  hashedPassword String? // Optional if using social logins primarily
  name           String?
  role           UserRole        @default(STAFF)
  createdAt      DateTime        @default(now())
  updatedAt      DateTime        @updatedAt
  sessions       Session[]
  // Add other user-specific fields like avatarUrl, preferences, etc.
}

model Session {
  id        String   @id @default(cuid())
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  expiresAt DateTime
  // deviceInfo String? // Store device info for security
  // ipAddress  String?

  @@index([userId])
}

// For external order tracking (Trendyol GO, Yemeksepeti etc.)
model ExternalOrder {
  id                      String              @id @default(cuid()) // Internal unique ID
  platform                String // e.g., "Trendyol GO", "Yemeksepeti"
  platformOrderId         String // The ID from the external platform
  shortCode               String?             // Derived code for quick display
  customerName            String
  customerAddress         String
  customerPhoneNumber     String?
  itemsJson               Json? // Store ExternalOrderItem[] as JSON if not heavily queried, or use a related table
  subtotal                Float
  deliveryFee             Float
  platformFee             Float?
  totalAmount             Float // Amount paid by customer
  restaurantPayout        Float? // Amount restaurant receives
  status                  ExternalOrderStatus @default(PENDING_CONFIRMATION)
  paymentServiceType      String? // e.g., "Card - Delivery"
  platformIconUrl         String? // Or store as part of platform config
  notes                   String?
  placedAt                DateTime
  estimatedDeliveryTime   DateTime?
  deliveredAt             DateTime?
  cancelledAt             DateTime?
  cancellationReason      String?
  order                   Order?              @relation("OrderExternalOrders", fields: [internalOrderId], references: [id])
  internalOrderId         String?             @unique // Link to internal Order if applicable

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([platform, platformOrderId]) // Ensure unique orders per platform
  @@index([platform])
  @@index([status])
  @@index([placedAt])
  @@index([internalOrderId])
}

model DeliveryPlatform {
  id        String   @id @default(cuid())
  name      String   @unique
  apiKey    String? // API Key for the platform
  apiSecret String? // API Secret for the platform
  isEnabled Boolean  @default(true)
  iconUrl   String?  // URL to the platform's icon

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

enum TableStatus {
  AVAILABLE
  OCCUPIED
  RESERVED
  DIRTY
}

enum OrderStatus {
  OPEN // Order created, items can be added/modified
  IN_PROGRESS // Order sent to KDS, being prepared
  DONE // Order prepared, ready for payment/delivery
  PAID // Order paid
  CANCELLED // Order cancelled
}

enum PaymentMethod {
  CASH
  CARD
  MOBILE
}

enum UserRole {
  ADMIN
  MANAGER
  STAFF
}

enum ExternalOrderStatus {
  PENDING_CONFIRMATION
  PREPARING
  READY_FOR_PICKUP
  ON_THE_WAY
  DELIVERED
  CANCELLED_BY_RESTAURANT
  CANCELLED_BY_USER
}
